//pref
ambient|float|0.0|0.5|1 
diffuse|float|0.0|0.5|1 
specular|float|0.01|0.5|1
shininess|float|0.01|10.0|30
showGradient|bool|false
Phong shading by Marcus N Campbell Bannerman, 2009 <m.bannerman@gmail.com> GNU General Public License.|note
//vert
void main() {
	gl_TexCoord[1] = gl_MultiTexCoord1;
	gl_Position = ftransform();
}
//frag
uniform int loops;
uniform float stepSize, sliceSize, viewWidth, viewHeight;
uniform sampler3D intensityVol; //3DTexture containing brightness
uniform sampler3D gradientVol; //3DTexture containing gradient direction and magnitude
uniform sampler2D backFace;
uniform sampler1D TransferTexture;
uniform bool useTransferTexture;

uniform vec3 clearColor,lightPosition, clipPlane;
uniform float clipPlaneDepth;
uniform float ambient,diffuse,specular, shininess;
uniform bool showGradient;
void main() {
	// get normalized pixel coordinate in view port (e.g. [0,1]x[0,1])
	vec2 pixelCoord = gl_FragCoord.st;
	pixelCoord.x /= viewWidth;
	pixelCoord.y /= viewHeight;	
	// starting position of the ray is stored in the texture coordinate
	vec3 start = gl_TexCoord[1].xyz;
	vec3 backPosition = texture2D(backFace,pixelCoord).xyz;
	vec3 dir = backPosition - start;
	float len = length(dir);
	dir = normalize(dir);
	//next see if clip plane intersects ray
	if (clipPlaneDepth > -0.5) {
		gl_FragColor.rgb = clearColor;
		//next, see if clip plane faces viewer
		bool frontface = (dot(dir , clipPlane) > 0.0);
		//next, distance from ray origin to clip plane
		float dis = dot(dir,clipPlane);
		if (dis != 0.0  )  dis = (-clipPlaneDepth - dot(clipPlane, start.xyz-0.5)) / dis;
		if ((!frontface) && (dis < 0.0)) discard;
		if ((frontface) && (dis > len)) discard;
		if ((dis > 0.0) && (dis < len)) {
			if (frontface) {
				start = start + dir * dis;
			} else {
				backPosition =  start + dir * dis; 
			}
			dir = backPosition - start;
			len = length(dir);
			dir = normalize(dir);		
		}	
	}	

	vec3 deltaDir = dir * stepSize;
	vec4 colorSample,gradientSample,colAcc = vec4(0.0,0.0,0.0,0.0);
	float lengthAcc = 0.0;
	//We need to calculate the ray's starting position. We add a random
	//fraction of the stepsize to the original starting point to dither the output
	vec3 samplePos = start.xyz + deltaDir* (fract(sin(gl_FragCoord.x * 12.9898 + gl_FragCoord.y * 78.233) * 43758.5453));
	//float specularColor = 1.0; //pure white, for red... vec3 specularColor= vec3(1.0,0.0,0.0); 
	vec4 prevNorm = vec4(0.0,0.0,0.0,0.0);
	float specularColor = 1.0; //pure white, for red... vec3 Specular = vec3(1.0,0.0,0.0); 
	float stepSizex2 = stepSize * 2.0;
	for(int i = 0; i < loops; i++) {
		if (useTransferTexture) {
			colorSample.a = texture3D(intensityVol,samplePos).a;
			colorSample= texture1D(TransferTexture, colorSample.a).rgba;
		} else {
			colorSample = texture3D(intensityVol,samplePos);
		}
		colorSample.a = 1.0-pow((1.0 - colorSample.a), stepSize/sliceSize);//opacity correction
		
		gradientSample= texture3D(gradientVol,samplePos); //interpolate gradient direction and magnitude
		gradientSample.rgb = normalize(gradientSample.rgb*2.0 - 1.0); //direction saved as 0..1, rescale to -1..1
		//re-use previous normal if it has larger magnitude
		if (gradientSample.a < prevNorm.a)
			gradientSample.rgb = prevNorm.rgb;
		prevNorm = gradientSample;
		if (showGradient)
			colorSample.rgb = abs(gradientSample.rgb);

		if ((gradientSample.a > 0.01) && (lengthAcc > stepSizex2)  ) {
			float lightNormDot = dot(gradientSample.rgb, lightPosition);
			//Diffuse lighting
			float diffTerm =  max(0.5 * lightNormDot + 0.5, 0.5);
			//Quadratic falloff of the diffusive term
			diffTerm *= diffTerm;
			colorSample.rgb *= diffuse* (diffTerm + ambient) + (1.0 - diffuse);
			//specular
			if (lightNormDot > 0.0) 
				colorSample.rgb +=   specular*specularColor * pow(max(dot(reflect(lightPosition, gradientSample.rgb), dir), 0.0), shininess);
		}

		colorSample.rgb *= colorSample.a; 
		//accumulate color
		colAcc= (1.0 - colAcc.a) * colorSample + colAcc;
		samplePos += deltaDir;
		lengthAcc += stepSize;
		// terminate if opacity > 1 or the ray is outside the volume
		if ( lengthAcc >= len || colAcc.a > 0.95 )
			break;
	}
	colAcc.a = colAcc.a/0.95;
	if ( colAcc.a < 1.0 )
		colAcc.rgb = mix(clearColor,colAcc.rgb,colAcc.a);
	gl_FragColor = colAcc;
}